
\begin{comment}
	\jw{Intuitive introduction to the subject matter, no formulas or definitions. \\
	- Start by firstly introducing trace abstraction: explaining safety of programs \\
	- Introduce program loops, mention what problems they cause $\rightarrow$ nesting, branching etc \\
	- then the 3 possible techniques: unwinding, invariant calculation, summarization with focus on summarization\\
	- related work \\
	- use simple running example \\
	- Continue to accelerated interpolation, intuitively explain how it works and how it integrates loop summaries $\rightarrow$ meta traces \\
	- Say that Ultimate already has a myriad of loop summarization techniques such as FastUPR and Jordan and show their drawbacks, such as Jordan being only to deal with no variable relations and FastUPRs lack of branching support. \\
	- Introduce qvasr as a solution  \\
	IMPORTANT: Only INTUITIVE explanations, no definitions \\ 
	\vspace{1cm}
	3 pages}
\end{comment}


Analyzing program loops is an important part of multiple software engineering tasks, such as bug detection, test case generation, and optimization. Loop analysis is, however, one of the most challenging aspects of program analysis, especially with complex loops that feature multiple paths and nested loops. Loop analysis has been called the `Achilles heel` of program verification\cite{DBLP:journals/fmsd/KroeningSTTW13}. \par
There are three prominent techniques of loop analysis: loop unwinding, loop invariant calculation, and loop summarization\cite{DBLP:journals/fmsd/KroeningSTTW13 , DBLP:conf/cav/SilvermanK19, DBLP:journals/tse/XieCZLLL19}. Loop unwinding deals with a loop by unrolling each loop iteration until a certain bound. This technique is quite simple but cannot reason about the program's behavior beyond the unwinding bound. \\
Loop invariants are properties that hold before and after each loop iteration, defining the loop's behaviour as constraints. The meaningfulness of loop invariants is however tied to their constraints' strength. Finding sufficiently strong invariants "is an art"\cite{DBLP:journals/fmsd/KroeningSTTW13}. A software-model checker, for example, may not terminate if given loop invariants are too general. \par
Loop summarization on the other hand provides a more accurate and complete view of the loop. A loop summary models the relationship between inputs and outputs as a transition formula which can be used to approximate the effect a loop has on program variables. Loop summaries are not guaranteed to be precise, they can over- or underapproximate the loop's effect. Counterexamples found using underapproximative loop summaries are guaranteed to be feasible. But due to the underapproximate nature of the summaries they can miss other feasible counterexample as they model only a subset of the actual loop behavior \cite{DBLP:journals/fmsd/KroeningLW15}. Loop summaries that overapproximate the loop's behaviour on the other hand form a superset of the actual loop behavior, resulting in possible spurious counterexamples. The quality of overapproximative loop summaries depends on the degree of overapproximation of the actual loop behavior. \par
Silverman and Kincaid\cite{DBLP:conf/cav/SilvermanK19} proposed an overapproximative loop summarization that \textsl{guarantees} a certain degree of approximation precision.
This proposed technique makes use of vector addition systems which are a prominent class of infinite-state transition systems with decidable reachability \cite{DBLP:conf/rp/HaaseH14}. A vector addition system consists of a finite number of integer-typed variables. When a transition is taken, these variables are updated by an addition of a constant. Silverman and Kincaid use a variation of vector addition systems that are based on rational-typed variables instead of integers with the notion of reset transitions which set variables to zero. When a transition is taken in a rational vector addition systems (\qvasr) a variable is either incremented by a constant, reset to 0, or reset and incremented.
\qvasr by themselves are a precise method of loop summarization, however, they can only deal with constant variable updates and updates that reference only the updated variable itself, for example \st{x:=x+1} or \st{y:=42}. Most loops contain variable updates, for instance \st{x:=y+x}, which cannot be represented by a \qvasr. To remedy this, Silverman and Kincaid introduce so called \qvasr abstractions, which are \qvasr extended by a, so-called, simulation matrix which projects the loop's transitions to changes between variable relations. For example, for assignments \st{z:=x}, \st{x:=x+y}, \st{y:=y+1}, we would get the relation $-x + y + z = 1$.
This \qvasr abstraction is an overapproximation as it no longer models changes to specific variables but to variable relations.\par
\qvasr abstractions only model changes to variables and do not factor in program assumptions, such as the loop guard or \st{if $\ldots$ else} statements. This leads to a loss of precision as the loop summaries' transitions are taken nondeterministically. This problem lead to the introduction of rational vector addition systems with resets and states (\qvasrs), which expand \qvasr abstractions by making use of states that model the original program's control flow.\par
The goal of this thesis was to adapt a loop summarization technique making use of \qvasr in the trace abstraction\cite{10.1007/978-3-642-03237-0_7} model checking scheme used in the software analysis framework \textsc{Ultimate}\cite{Zitat02}.
\textsc{Ultimate} consists of multiple plugins and libraries for various software verification tasks and already features numerous loop summarization techniques, they, however, are struggling with, loop branching, assignments to variables that are not constant, as for example \st{x:=x+y}, and approximation precision.\par
Our contribution is the adaption of a \qvasr based loop summarization library to the trace abstraction scheme used in \textsc{Ultimate}. We implemented two approaches:
\begin{itemize}
	\item Summarizing loops directly on traces computed by trace abstraction, then abstracting them in the \textsl{Accelerated Interpolation} framework, which then computes state assertions constraining values to program variables.
	\item Using \qvasr summarization as a preprocessor for trace abstraction, which transforms a program's control flow graph, by replacing loops with \qvasr summaries, such that, the traces trace abstraction computes already contain loop summaries.
\end{itemize}

The remainder of this master's thesis is structured as follows, in Chapter \ref{relWork} we will give a brief summary of other kinds of loop summarization techniques each with their strength and weaknesses. In chapter \ref{background} we introduce our notations and definitions of logical formulas, programs, traces, and outline trace abstraction. Further, in chapter \ref{qvasr} we introduce the loop summarization technique using rational vector addition systems with resets (\qvasr), and expand them to \qvasr abstractions. Chapter \ref{qvasrs} serves as an introduction to \qvasrs by further extending \qvasr to make use of states. In Chapter \ref{traceabstractionVasr} we present the \textsl{accelerated interpolation} paradigm, and its usage of \qvasr loop summaries. We also adapted \qvasr to be used as a control-flow graph transformer, which will be outlined in chapter \ref{icfgTransformation}. The new loop summarization library was tested extensively, both in \textsl{Accelerated Interpolation} and as control-flow graph transformer. It was measured against other loop acceleration techniques using the set of \texttt{sv-comp} benchmarks \cite{svcomp}. The results will be shown and discussed in chapter \ref{eval}. After the evaluation we discuss possible improvements in Chapter \ref{futrWork}. Last, but not least, we give a conclusion on this project in chapter \ref{concl}.

