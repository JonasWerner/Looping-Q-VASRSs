\newcommand{\stateSpace}{\ensuremath{S_{V, \mu}}}
\begin{comment}
	This chapter is mostly focused on trace abstraction $\rightarrow$  It introduces the reader to the concept of trace abstraction. \\
	- Introduce logic, logical variables, terms, formulas, transition formulas with primed and unprimed variables, programs, program states, loops $\rightarrow$  then program-, error traces, feasible and infeasible counterexamples, CFGs, interpolants. \\ - From intuitive to true definitions. \\
	Here the running example from the introduction gets dissected to illustrate the definitions. \\ 
	Further the problems loops can cause are introduced, followed by a definition of loop summaries $\rightarrow$ introduction reflexive transitive closure of a formula 
	15 pages
\end{comment}

This chapter shall introduce our understanding and notation of logic and formulas, programs, control-flow, and other needed background definitions. Furthermore, we will give an overview of the \traceabstraction \cite{10.1007/978-3-642-03237-0_7} counterexample-guided abstraction refinement scheme used in \ultimate.

\subsection{Logical Background}
To represent programs formally, we make use of first-order logic. This chapter will introduce our definitions and notations used throughout this thesis.

\subsubsection{Notation}
We utilize the standard logical notations: We represent boolean values as $\bot$, meaning \textsl{false}, and $\top$, meaning \textsl{true}. \\ Logical connectives are defined as:
\begin{itemize}
	\item Negation (\textsl{not}) denoted by: $\neg$
	\item Conjunction (\textsl{and}) denoted by: $\land$
	\item Disjunction (\textsl{or}) denoted by: $\lor$
	\item Implication (\textsl{if $\ldots$ then}) denoted by: $\rightarrow$
	\item Biconditional (\textsl{if and only if}) denoted by: $\leftrightarrow$
\end{itemize}
Formulas can be quantified, we define quantifiers as:
\begin{itemize}
	\item Existential quantification (\textsl{there exists}) denoted by: $\exists$
	\item Universal quantification (\textsl{for all}) denoted by: $\forall$
\end{itemize}

\subsubsection{Syntax}
We firstly introduce our first-order logic syntax.
Let $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$ be a vocabulary consisting of the countable sets:
\begin{itemize}
	\item $\vocab{Var}$ containing all so called \textsl{variables}
	\item $\vocab{Const}$ containing all so called \textsl{constant symbols}
	\item $\vocab{Fun} $ containing all so called \textsl{function symbols}. Each symbol $f \in \vocab{Fun}$ has a natural number $\geq 1$ called arity of $f$
 	\item $\vocab{Pred}$ containing all so called \textsl{predicate symbols}. Each symbol $p \in \vocab{Pred}$ has a natural number $\geq 0$ called arity of $p$
\end{itemize}
Assume we are given such a vocabulary, we can construct first-order logic terms using the symbols in the vocabulary.
\begin{mydef}[Term] 
	Given a vocabulary $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$, we define terms inductively as follows:
	\begin{itemize}
		\item Every $x \in \vocab{Var}$ is a term.
		\item Every $c \in \vocab{Const}$ is a term.
		\item If $t_0, \ldots, t_n$ are terms and $f \in \vocab{Fun}$ being a function symbol with arity $n$, then $f(t_0, \ldots, t_n)$ is a term.
	\end{itemize}
\end{mydef}
Using first-order logic terms, we can introduce first-order logic formulas.
\begin{mydef}[Formula]
	Given vocabulary $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$, first-order logic formulas are inductively defined as follows:
	\begin{itemize}
		\item $\bot$ is a formula.
		\item If  $t_0, \ldots, t_n$ are terms, and $p \in \vocab{pred}$ is a predicate symbol with arity $n$, \\ then $p(t_0, \ldots, t_n)$ is a formula.
		\item If $\varphi$ is a formula, then $\neg \varphi$ is a formula.
		\item If $\varphi$ and $\psi$ are formulas, then $\varphi \land \psi$ are formulas.
		\item If $\varphi$ is a formula, and $x \in \vocab{Var}$ then $\exists x. \varphi$ is a formula.
	\end{itemize}
\end{mydef}
To give variables, constants, functions, and predicates concrete values, we can assign them a model.
\begin{mydef}[Model]
	Given vocabulary $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$, a model $\mathcal{M} = (D, \interpret)$ is a tuple consisting of a nonempty set $D$, called interpretation domain, and an interpretation function \interpret that assigns constants, functions, and predicates over $D$ to symbols in $V$. $M$ has the following characteristics:
	\begin{itemize}
		\item The domain of \interpret is $\vocab{Const} \cup \vocab{Fun} \cup \vocab{Pred}$
		\item \interpret maps every constant symbol $c \in \vocab{Const}$ to an element in $D$
		\item \interpret maps every function symbol $f \in \vocab{Fun}$, with arity $n$, to a corresponding n-ary function with domain $D^n$ and range $D$
		\item \interpret maps every predicate symbol $p \in \vocab{Pred}$ with arity $n$ to an n-ary relation over the domain $D$
	\end{itemize}
\end{mydef}
Using a model, we can now assign concrete values to variables.
\begin{mydef}[Assignment of Variables]
	Given vocabulary $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$, and model $\mathcal{M} = (D, \interpret)$, an assignment of variable $v \in \vocab{Var}$ is a function $\rho: v \rightarrow D$. Mapping each variable a value in domain $D$.
\end{mydef}
Assume $f \in \vocab{Fun}$ is a function defined as $f: X \rightarrow Y$ with some domain $X$ and range $Y$. Let $x \in X$ and $y \in Y$, we use $f[x \rightarrow y]$  to denote the function that maps all $\bar{x} \in X \backslash \{ x \}$ to $f(\bar{x})$ and $x$ to $y$.

\subsubsection{Semantics}
Assume we are given a vocabulary $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$, we know how to assign values using models and variable assignments. The task now is to understand how to interpret them. This section serves to introduce semantics of fist-order logic.
\begin{mydef}[Evaluation of Terms]
	Let $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$ be a vocabulary, $\mathcal{M} = (D, \interpret)$ a model, and $\rho$ a variable assignment. The evaluation of terms is a function $\eval{\cdot}$ that is inductively defined as:
	\begin{itemize}
		\item For each $v \in \vocab{Var}$, $\eval{v} = \rho(v)$
		\item For each $c \in \vocab{Const}$, $\eval{c} = \interpret(c)$
		\item If $t_0, \ldots, t_n$ are terms, $f \in \vocab{Fun}$, with f having arity $n$ then \\ $\eval{f(t_0, \cdots, t_n)}$ is $\interpret(f)(\eval{t_0}, \ldots, \eval{t_n})$
	\end{itemize}
\end{mydef}
From the evaluation of terms we can derive the evaluation of formulas, which decides whether a formula is \textsl{true} or \textsl{false}.

\begin{mydef}[Evaluation of Formulas]
		Let $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$ be a vocabulary, $\mathcal{M} = (D, \interpret)$ a model, a variable assignment $\rho$, and $\varphi_0, \varphi_1$ being first-order logic formulas over $V$. The evaluation of formulas is a function $\eval{\cdot}$ that is inductively defined as: \\
		\begin{itemize}
			\item {\makebox[3cm]{$\eval{\bot} \hfill$}} \textbf{false}
			\item {\makebox[3cm]{$ \eval{p(t_0, \ldots, t_n)} \hfill$}} 
				$
				\begin{cases}
					\textbf{true}, & \text{for } (\eval{t_0}, \ldots, \eval{t_n}) \in \interpret(p)\\
					\textbf{false}, & \text{otherwise}
				\end{cases}
				$
			\item {\makebox[3cm]{$\eval{\neg \varphi_0} \hfill$}}
				$
				\begin{cases}
					\textbf{true}, & \text{for } \eval{\varphi_0} \text{ \textbf{false}}\\
					\textbf{false}, & \text{for } \eval{\varphi_0} \text{ \textbf{true}}\\
				\end{cases}
				$
			\item {\makebox[3cm]{$\eval{\varphi_0 \land \varphi_1} \hfill$}}
				$
				\begin{cases}
					\textbf{true}, & \text{for } \eval{\varphi_0} \text{ \textbf{true} and } \eval{\varphi_1} \text{ \textbf{true}} \\
					\textbf{false}, & \text{otherwise} \\
				\end{cases}
				$
			\item {\makebox[3cm]{$\eval{\exists v. \varphi_0} \hfill$}}
				$
				\begin{cases}
					\textbf{true}, & \text{if there exists } x \in D \text{ where } \eval{\varphi_0 [v \rightarrow x]} \text{ \textbf{true}} \\
					\textbf{false}, & \text{otherwise} \\
				\end{cases}
				$
		\end{itemize}
\end{mydef}

\subsection{Programs}
In this chapter we will introduce our understanding on how to model programs using first-order logic. We will begin with our syntax of programs, then explain program statement semantics.

\subsubsection{Program Syntax}
Assume we are given the example program as seen in figure \ref{code}. We see that the code contains various typed variables such as \texttt{x : int} and instructions over these variables. \\ These instructions use the following context-free grammar $\Sigma$ that is a derived and simplified version of the grammar of the intermediate verification language Boogie\cite{Boogie}.
\setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RHS
\begin{figure}[H]
	\input{fig/grammar.tex}
	\caption{Context-free grammar $\Sigma$ detailing program instructions.}
	\label{grmr}
\end{figure}
We call words derived from $\langle Stmt \rangle$ program statements, words derived from $\langle Expr \rangle$ expressions, and $Var_{id}$ represent the program variables.
We define programs as follows:

\begin{mydef}[Programs]
	A program is a triple $P = (V, \mu, st)$, with $V$ being a set of variables, a function $\mu: V \rightarrow \{ \mathbb{Z}, \mathbb{R}, \mathbb{B} \}$ that maps variables $v \in V$ to a domain, which is either the set of integers, the rational numbers, or boolean values $\mathbb{B} = \{\textbf{true}, \textbf{false}\}$. Furthermore, $st$ is a derived word from $\Sigma$ representing the program instructions.
\end{mydef}
\subsubsection{Program Semantics}
We see in figure \ref{grmr} that there are five kinds of program statements: An assumption over variables \texttt{assume}, an assignment to variables \texttt{:=}, a non deterministic assignment \texttt{havoc}, an assertion on variable values \texttt{assert}, a program loop \texttt{while}, that repeats a statement until its loop guard, the $\langle WildcardExpr \rangle$ in $\Sigma$, no longer holds, and an conditional branching, in form of an \texttt{if else} statement. \\
Most program statements change the assignment of variables and with that changes the state a program is in. 
\begin{mydef}[Program State]
	Given a program $P = (V, \mu, st)$ a program state is a function $\sigma: V \rightarrow \mu(V)$ that assigns each variable $v \in V$ a value in its domain $\mu(v)$. We denote the set of all program states as \stateSpace.
\end{mydef}


\begin{comment}
	\begin{mydef}[Sets of Program States]
	To represent multiple program states we use first-order logic formulas. Given a first-order logic formula $\varphi$, defined over variables in $V$, we denote $\{\varphi\} = \{s \in \stateSpace | \eval{\varphi} \text{ where } \rho = s\}$
	\end{mydef}
\end{comment}


\begin{center}
	\begin{minipage}[b]{0.4\linewidth}
			\begin{figure}[H]
			\centering
			\input{fig/lst_ex_p0.tex}
			\caption{Program $P$ \\ with \texttt{while} loop.}
			\label{code}
		\end{figure}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.59\linewidth}
		\begin{figure}[H]
			\centering
			\input{fig/fig_ex_p0_cfg.tex}
			\caption{Control-flow graph for program $P$.}
			\label{code}
		\end{figure}
	\end{minipage}
\end{center}


\subsection{Model Checking}
\begin{mydef}[Control-Flow Graph]
	Given a finite set of program statements \stmt. A control-flow graph is a labelled graph $G_P = (\Loc, \delta, \loc{\init}, \loc{\err})$, with
	\Loc being a finite set of locations,
	a set of edges between two locations labelled with a statement $\delta \subseteq \Loc \times \stmt \times \Loc$,
	an initial location $\loc{init} \in \Loc$, and
	an error location $\loc{err} \in \Loc$.
\end{mydef}
In this paper we will use control-flow graphs to represent programs.


\subsection{Trace Abstraction}