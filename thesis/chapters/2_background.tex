
\begin{comment}
	This chapter is mostly focused on trace abstraction $\rightarrow$  It introduces the reader to the concept of trace abstraction. \\
	- Introduce logic, logical variables, terms, formulas, transition formulas with primed and unprimed variables, programs, program states, loops $\rightarrow$  then program-, error traces, feasible and infeasible counterexamples, CFGs, interpolants. \\ - From intuitive to true definitions. \\
	Here the running example from the introduction gets dissected to illustrate the definitions. \\ 
	Further the problems loops can cause are introduced, followed by a definition of loop summaries $\rightarrow$ introduction reflexive transitive closure of a formula 
	15 pages
\end{comment}

This chapter shall introduce our understanding and notation of logic and formulas, programs, control-flow, and other needed background definitions. Furthermore, we will give an overview of the \traceabstraction \cite{10.1007/978-3-642-03237-0_7} counterexample-guided abstraction refinement scheme used in \ultimate.

\subsection{Logical Fundamentals}
We use first-order logic to model programs, this chapter will introduce our definitions and notations used throughout this thesis.
\begin{mydef}[Term] 
	Given a vocabulary $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$, with countable sets $\vocab{\Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred}$ representing the sets of variables, constant symbols, function symbols, and predicate symbols respectively, we define terms inductively as follows:
	\begin{itemize}
		\item Every $x \in \vocab{Var}$ is a term.
		\item Every $c \in \vocab{Const}$ is a term.
		\item If $t_0, \ldots, t_n$ are terms and $f \in \vocab{Fun}$ being a function symbol with arity $n$, then $f(t_0, \ldots, t_n)$ is a term.
	\end{itemize}
\end{mydef} \vspace*{1cm} \par
Using the definitions of terms, we can introduce first-order logic formulas.

\begin{mydef}[Formula]
	Given vocabulary $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$, first-order logic formulas are inductively defined as follows:
	\begin{itemize}
		\item $\bot$ (\textsc{false}) is a formula.
		\item If  $t_0, \ldots, t_n$ are terms, and $p \in \vocab{pred}$ is a predicate symbol with arity $n$, \\ then $p(t_0, \ldots, t_n)$ is a formula.
		\item If $\varphi$ is a formula, then $\neg \varphi$ is a formula.
		\item If $\varphi$ and $\psi$ are formulas, then $\varphi \land \psi$ are formulas.
		\item If $\varphi$ is a formula, and $x \in \vocab{Var}$ then $\exists x. \varphi$ is a formula.
	\end{itemize}
\end{mydef} \vspace*{1cm} \par

\begin{mydef}[Model]
	Given vocabulary $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$, a model $\mathcal{M} = (D, \interpret)$ is a tuple consisting of a nonempty set $D$, called interpretation domain, and an interpretation function \interpret that assigns constants, functions, and predicates over $D$ to symbols in $V$.
\end{mydef}

\begin{mydef}[Assignment of Variables]
	Given vocabulary $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$, and domain $D$, an assignment of variable $v \in \vocab{Var}$ is a function $\varv: v \rightarrow D$.
\end{mydef}

\begin{mydef}[Evaluation of Terms]
	Let $V = (\vocab{Var}, \vocab{Const}, \vocab{Fun}, \vocab{pred})$ be a vocabulary, $\mathcal{M} = (D, \interpret)$ a model, and $\varv$ a variable assignment, the evaluation of terms is a function $\eval{\cdot}$ that is inductively defined as:
	\begin{itemize}
		\item For each $x \in \vocab{Var}$, $\eval{x} = \varv(x)$
		\item For each $c \in \vocab{Const}$, $\eval{c} = \interpret(c)$
		\item If $t_0, \ldots, t_n$ are terms, $f \in \vocab{Fun}$, and f has arity $n$ then \\ $\eval{f(t_0, \cdots, t_n)}$ is $\interpret(f)(\eval{t_0}, \ldots, \eval{t_n})$
	\end{itemize}
\end{mydef}

\subsection{Programs}
Assume we are given a program as seen in \ref{code}. We consider each line of code a so called program statement. These statements use the following context-free grammar that is a derived and simplified version of the grammar of the intermediate verification language Boogie\cite{Boogie}.
\setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RHS 
\begin{grammar}
	<Stmt> ::= `assume' <Expr> ;
	\alt $Var_{id}$ `:=' <Expr> ;
	\alt `havoc' $Var_{id}$ ;
	\alt `assert' <Expr> ;
	\alt `while' ( <WildcardExpr> ) <Stmt>* ;
	\alt <IfStmt>;
	
	<IfStmt> ::= `if' ( <WildcardExpr> ) <Stmt>* `else' <Stmt>*

	<Expr> ::= <Expr> <BinOp> <Expr>
	\alt <UnOp> <Expr>
	\alt `True'
	\alt `False'
		
	<WildCardExpr> ::= <Expr> | `*'
	
	<BinOp> ::= `+' | `-' | `*' | `/' | `\%'
	\alt `\&\&' | `||' | `==' | `!='
	\alt `<' | `<=' | `>' | `>='
	
	<UnOp> ::= `-' | `!'
\end{grammar}
Where $Var_{id}$ represents any variable declared in the program and $*$ corresponds to a nondetermnistic choice.
For brevity's sake we use \texttt{bexpr} instead of \texttt{assume bexpr}.

\begin{mydef}
	Given a finite set of program statements \stmt. A control-flow graph is a labelled graph $G_P = (\Loc, \delta, \loc{\init}, \loc{\err})$, with
	\Loc being a finite set of locations,
	a set of edges between two locations labelled with a statement $\delta \subseteq \Loc \times \stmt \times \Loc$,
	an initial location $\loc{init} \in \Loc$, and
	an error location $\loc{err} \in \Loc$.
\end{mydef}
In this paper we will use control-flow graphs to represent programs.
% \dd{It is useful to wrap all the function symbols in Latex macros}
% \ts{And to use mathit for identifiers consisting of several letters (like $\mathit{Var}$)}
Program variables are typed, e.g. integer or boolean variables, there exists \\
an interpretation domain $D$ defining the set of all possible variable values.
\jw{TODO}
Assigning every program variable a valuation creates a program state.

%the n may be wrong, because traces can be infinite in theory? no, because a program can only have finitely many variable declarations. The source code is finite.

\begin{mydef}
	Assume a program $P$ is defined over $n$ variables, a program state $\sigma$ is a function assigning each variable $v_i \in \Var$, \ $0 \leq i \leq n$ a variable valuation $\rho_i$. The set $S$ denotes the set of all program states.
\end{mydef}


\begin{mydef}
	Given the set of all expressions over program variables $\mathit{Expr}$, an interpretation function $\interpret: Expr \times \sigma \rightarrow D$ is a function assigning each expression $expr \in \mathit{Expr}$ a value in its domain $D$ with regard to the program state $\sigma$.
\end{mydef}


\ts{What is an interpretation function?}
\dd{Perhaps you should explain what your interpretation function is :p}

Program statements can change the valuation of variables, transitioning one program state to another.

\begin{mydef}
	Each program statement $\texttt{s} \in \stmt$ defines a binary relation $\rho \subseteq S \times S$ over the set of program states $S$, called successor relation. Which is, given interpretation function $\mathcal{I}$, inductively defined as
	$$ \rho =
	\begin{cases}
		\{(\sigma, \sigma')\ |\ \mathcal{I}(\text{bexpr})(\sigma)\ =\ true\ \text{and}\ \sigma = \sigma'\} ,                                        & \text{if}\ s \equiv \text{\texttt{assume bexpr}} \\
		\{(\sigma, \sigma')\ |\ \sigma' = \sigma[x \mapsto \mathcal{I}(expr)(\sigma)]\} ,                                                           & \text{if}\ s \equiv \texttt{x := expr}           \\
		\{(\sigma, \sigma')\ |\ \exists \sigma''\ \text{where}\ (\sigma, \sigma'') \in \rho(s_1)\ \text{and}\ (\sigma'', \sigma') \in \rho(s_2) \}, & \text{if}\ s \equiv \texttt{$s_1;s_2$}
	\end{cases}
	$$
\end{mydef}
%	\ts{You already used $\rho$ for valuation.}
\begin{mydef}
	\jw{Sets of States.}
\end{mydef}
\begin{center}
	\begin{minipage}[b]{0.4\linewidth}
			\begin{figure}[H]
			\centering
			\input{fig/lst_ex_p0.tex}
			\caption{Program $P$ \\ with \texttt{while} loop.}
			\label{code}
		\end{figure}
	\end{minipage}
	\hfill
	\begin{minipage}[b]{0.59\linewidth}
		\begin{figure}[H]
			\centering
			\input{fig/fig_ex_p0_cfg.tex}
			\caption{Control-flow graph for program $P$.}
			\label{code}
		\end{figure}
	\end{minipage}
\end{center}


\subsection{Model Checking}


\subsection{Trace Abstraction}