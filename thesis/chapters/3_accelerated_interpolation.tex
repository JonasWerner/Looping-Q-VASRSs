
\begin{comment}
	\jw{Accelerated Interpolation as an extension of trace abstraction is introduced $\rightarrow$ Show how to utilize loop summaries within trace abstraction \\
	- Error traces  $\rightarrow$ loop relations  $\rightarrow$ reflexive transitive closures  $\rightarrow$ meta traces  $\rightarrow$ interpolation on meta traces \\
	- "We implemented accelerated interpolation in an earlier project using a myriad of loop summarization techniques... " $\rightarrow$ Introduce various loop summarization techniques (FastUPR, Jordan, Werner) NOT in-depth, only their ideas, but show their pros and cons  $\rightarrow$ The cons build a bridge to the next chapter \\
	- running example will be transformed to a meta trace WITHOUT actual loop summarizations on edges \\
	\vspace{1cm}
	22 pages $\rightarrow$ recycled from earlier}
\end{comment}

\subsection{Loops Without Branching}
Reconsider program $P_1$ from the previous chapter.
To prove its safety trace abstraction finds error trace $\tau_1$, as before, we detect a loop with $\loc{3}$ and minimal loop trace $\tau_{L_1}$ from which we construct the loop relation $\psi_{L_1}$.
It is evident that there is only one path through the loop, resulting in a loop without branching.
We consequently compute the loop acceleration $\psi^*_{L_1}$.

The loop acceleration contains every looping trace, meaning it is possible to replace the whole loop in the error trace by that acceleration, modelling a relation consisting of every loop trace.
\dd{Why not explain the idea of meta trace first and then give a definition?}

\begin{mydef}
	Given an error trace $\tau: s_0, s_1, \ldots, s_n$ containing loop $\tau_L: s_i, s_{i+1}, \ldots, s_j$ with loop head $\loc{L}$.
	A meta trace $\bar{\tau}$ is derived from $\tau$ by replacing $\tau_L$ with the loop acceleration.
	Furthermore, the last occurrence of $\loc{L}$ is replaced by a new loop exit $\loc{L}'$.
\end{mydef}
\ts{Now you have a mixture of statements and relations. Do you want to allow this (explanation required) or use transformulas in general?}
\dd{Which loop acceleration? Will you talk about properties of loop accelerations? What is a loop acceleration? Is it "the closure"? Or is it \emph{some} relation over program states that has some properties relative to a closure?}

\begin{comment}
The error trace $\tau_1$ creates the meta trace $\bar{\tau_1}$:
\begin{figure}[H]
\begin{tikzpicture}[%
->,
>=stealth', shorten >=1pt, auto,
node distance=2.5cm, scale=1,
transform shape, align=center,
smallnode/.style={inner sep=1.4}
initial text =]

\node[state](1){$\loc{1}$};

\node[state] (2) [right of=1] {$\loc{2}$};

\node[state] (3) [right of=2] {$\loc{3}$};

\node[state] (4) [right of=3] {$\loc{3}'$};

\node[state] (5) [right of=4, xshift=0.5cm] {$\loc{6}$};

\node[state] (6) [right of=5, xshift=0.5cm] {$\loc{7}$};

\path (1) edge node {\texttt{x := 0}} (2); \\
\path (2) edge node {\texttt{y := 1}} (3); \\
\path (3) edge node {$\psi^*_{L_1}$} (4);\\
\path (4) edge node[] {\texttt{!x <= 50}} (5); \\
\path (5) edge node {\texttt{y != 103}} (6); \\
;
\end{tikzpicture}
\captionof{figure}{Meta trace $\bar{\tau_1}$ generated from $\tau_1$ using $\psi^*_{L_1}$.}
\end{figure}
\end{comment}

\begin{figure}[H]
	\begin{center}
		\begin{tabular}{ccccccccccc}
			\loc{1} & \st{x:=0} & \loc{2} & \st{y:=1} & \loc{3} & \accel{1} & $\loc{3}'$ & \st{x>50} & \loc{6} & \st{y!=103} & \loc{7} \\
		\end{tabular}
	\end{center}
	\captionof{figure}{Meta trace $\bar{\tau_1}$ generated from $\tau_1$ using $\psi^*_{L_1}$.}
\end{figure}
We can now analyse this meta trace for feasibility using an SMT-solver such as SMTInterpol\cite{Zitat03} or z3\cite{z3}. We get the following labelling:

\begin{figure}[H]
	\centering
	\input{fig/fig_metatrace_and_proof.tex}
\end{figure}
\captionof{figure}{Meta trace $\bar{\tau_1}$ generated from $\tau_1$ and $\psi^*_{L_1}$ and its infeasibility proof.}
\label{fig:ex:t0:infproof}
%\dd{Do not capitalize captions. They are just normal sentences.}


\dd{Do you still need the line above?}

We cannot, however, use $I_{\bar{\tau_1}}$ to disprove $\tau_1$ as we need an interpolant for each location in the original trace.
\dd{say which one is missing ;)}
To remedy this, we derive an inductive interpolant sequence $I_{\tau_1}$ by applying the post operator.
\dd{Explain why we need post for the before-location, use the example here}

\newcommand{\accels}[1]{\ensuremath{\psi^{*}_{#1}}}
Given
\begin{itemize}[topsep=0pt,itemsep=-1ex,partopsep=1ex,parsep=1ex]
	\item an error trace $\tau: s_0 s_1 \ldots s_i \ldots s_j \ldots s_n$ where \loc{i} is a loop head for the loop $L$ spanning from $s_i$ to $s_j$,
	\item a loop relation $\psi_L$ for loop $L$,
	\item a corresponding loop acceleration \accels{L},
	\item the meta trace $\bar{\tau}: s_0 s_1 \ldots s_{i-1} \ \accels{L} \ s_{j+1} \ldots s_n$ derived from $\tau$ and \accels{L}, and
	\item the infeasibility proof $I_{\bar{\tau}}: \{\top, I_1, I_2, \ldots , I_i, I_{\psi^*_{L}}, \ldots , I_{n-1}, \bot \}$ for $\bar{\tau}$.
\end{itemize}
\dd{Fix indices s.t. we have the interpolant (sic!) before and after the loop acceleration}

To construct an inductive proof of infeasibility for $\tau$ we need inductive interpolants for the loop statements $s_i, \ldots , s_j$ that were replaced by $\psi^*_{L}$.

Firstly, compute post($I_{\psi^*_L}$, $\psi^*_L$) as the loop entry interpolant $I_{\loc{L}}$.
From there keep applying the post operator with the previous location's interpolant and the following program statement.

We get the inductive interpolant sequence
\begin{equation*}
	I_\tau: \{\top,I_1,I_2, \ldots ,\ \underbrace{post(I_i, \accels{L})}_{I_{i}^*},\ \ \underbrace{post(I_{i}^*, s_i)}_{I_{i+1}^*},\ \ldots ,\ \underbrace{post(I_{j-1}^*, s_j)}_{I_{j}^*},I_{j+1}, \ldots ,I_{n-1}, \bot \}
\end{equation*}
which can now be used by trace abstraction to refine the interpolant automaton.
\ts{Explain why this works and why it is necessary.}

We compute the missing interpolants for example program trace $\tau_1$ as follows:
\dd{Strange wording. This is just the continuaton of the example, right?}
\begin{comment}
\begin{figure}[H]
\centering
\input{fig/fig_iip.tex}
\captionof{figure}{Program trace $\tau_1$ of $P_1$ with inductive infeasibility proof.}
\end{figure}
\end{comment}

\begin{figure}[H]
	\begin{center}
		\input{fig/fig_iip_new.tex}
	\end{center}
\end{figure}
\captionof{figure}{Program trace $\tau_1$ of $P_1$ with inductive infeasibility proof.}
\label{fig:ex:t0:infproof}

% \ts{The simplification of the interpolant at $\loc{6}$ is wrong.}

\subsection{Loops With Branching}
\dd{What about the part where we check if we can accelerate with branches?}
The programs shown before contained loops that had only one distinct minimal loop trace.
However, most programs contain loops with branching paths, caused, for example, by \texttt{if} and \texttt{else} statements.
These case distinctions create multiple minimal loop traces that differ from one another.
This section introduces our technique of dealing with branching loops.

\ts{``our'' - explain which parts differ from the paper.}

\begin{figure}[H]
	\centering
	\begin{subfigure}{0.3\textwidth}
		\centering
		\input{fig/lst_ex_p2.tex}
		\caption{Program code.}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.6\textwidth}
		\centering
		\input{fig/fig_ex_p2_cfg.tex}
		\caption{Control-flow graph $G_{P_2}$.}
	\end{subfigure}
	\captionof{figure}{Example program $P_2$.}\label{fig:ex:p2}
\end{figure}

To illustrate branching loops, assume we are given program $P_2 = (Loc_2, \delta_2, \loc{1}, \loc{9})$ depicted in Figure~\ref{fig:ex:p2}.
It is evident that \loc{2} is a loop head.
However, it is not possible to apply the technique described in the previous chapter as it is not possible to construct a single minimal loop trace.
The branching created by the \texttt{if} and \texttt{else} statements in the program code, translated to \texttt{assume} statements in the control-flow graph, implies infinitely many loop traces that cannot be summarized by a single minimal loop trace.

\begin{mydef}
	Given a
	program $P = (\Loc, \delta, \ell_\init, \ell_\err)$ and an
	error trace $\tau: s_0s_1\ldots\ s_n$ with
	loop trace $\tau_L: s_i, s_{i+1}, \ldots, s_j$.
	The loop is called branching if there is a program location $\loc{B}$
	where there is a statement $s_k \in \tau_L\ \text{with}\ (\loc{B}, s_k, \loc{l}) \in \delta$
	and there is a program statement $s_l \in \tau_L\  \text{with}\ (\loc{B}, s_l, \loc{m}) \in \delta$.
\end{mydef}
%\ts{Don't use quantifiers as abbreviation in text.}
\dd{Makes no real sense, because the definition does not talk about a ``loop''}
To accelerate branching loops we have to separate each loop branch into its own loop, for which it is possible to compute a minimal loop trace.



Assume that trace abstraction generated the following error trace $\tau_2$ of program $P_2$:
\begin{figure}[H]
	\begin{center}
		\input{fig/fig_ex_p2_tau2.tex}
	\end{center}
	\captionof{figure}{Program trace $\tau_2$ of $P_2$}
\end{figure}
\dd{Note that this is not a trace -- a trace is a statement sequence}
\dd{When you use pictures or tables as text elements, they should not be floating figures and should not have their own captions. For traces, this is sometimes (usually?) appropriate}

Program location $\loc{2}$ appears five times making it a loop head with loop trace:
\begin{align*}
	\tau_L: & \st{x<=10}\st{x-4<=1}\st{x:=x+2}\st{x:=x+2}\st{x<=10}\st{x-4<=1}\st{x:=x+2}\st{x:=x+2} \\&\st{x<=10}\st{x-4>1}\st{x:=x+1}\st{x:=x+2}\st{x<=10}\st{x-4>1}\st{x:=x+1}\st{x:=x+2}
\end{align*}
Because \begin{itemize}
	\item ($\loc{3}$, \st{x-4<=1}, $\loc{5}$) $\in \delta_2$ and \st{x-4<=1} $\in \tau_L$
	\item ($\loc{3}$, \st{x-4>1}, $\loc{4}$) $\in \delta_2$ and \st{x-4>1} $\in \tau_L$
\end{itemize}
the loop is branching.
We separate the loop branches by checking the program statements in the intervals between the loop head repetition and get two minimal loop traces:
\dd{This seems rather hand-wavey}
\begin{align*}
	& \tau_{L_1}:\ \st{x<=10}\st{x-4<=1}\st{x:=x+2}\st{x:=x+2} \\
	& \tau_{L_2}:\ \st{x<=10}\st{x-4>1}\st{x:=x+1}\st{x:=x+2}
\end{align*}
With loop relations:
\begin{align*}
	\psi_{L_{1}} & : \{(\sigma, \sigma')\ |\ \sigma[x] \leq 5 \land  \sigma'[x] = \sigma[x] + 4 \}                      \\
	\psi_{L_{2}} & : \{(\sigma, \sigma')\ |\ \sigma[x] \leq 10 \land \sigma[x] > 5 \land  \sigma'[x] = \sigma[x] + 3 \}
\end{align*}
\dd{It might pay of to introduce a shorthand for this, e.g., $x \leq 5 \land x'=x+4 $}
Using these two relations we can approximate an iteration of the loop as $\tau_{L_1} \lor \tau_{L_2}$.
\dd{Approximate in which direction? Up or down? Over or under?}

As we have now sensible minimal loop traces for both branches of the loop, it is possible to compute a loop acceleration the same way as in previous chapters:
\begin{align*}
	\psi_{L_{1}}^* & : \{(\sigma, \sigma')\ |\ (\sigma'[x] \leq 9 \lor \sigma[x]' \leq x)\ \land\ 3\cdot \sigma'[x] + \sigma[x]\ (mod\ -4) = 0\ \land\ \sigma[x] \leq \sigma'[x] \} \\
	\psi_{L_{2}}^* & : \{ (\sigma, \sigma')\ | \ \sigma[x] \leq \sigma'[x]\ \land\ \sigma'[x] + 2 \cdot \sigma[x]\ (mod\ 3) = 0                                                     \\
	& \hspace*{1.75cm} \land\ 3 < \sigma[x]\ \land\ \sigma'[x] \leq 13 \ \lor \sigma'[x] = \sigma[x]\}
\end{align*}

To utilize them in accelerated interpolation we firstly need to introduce a meta trace variant for branching loops.

\begin{mydef}
	Given an error trace $\tau: s_0, s_1, \ldots, s_n$ containing a loop $\tau_L: s_i, s_{i+1}, \ldots, s_j$ with loop head $\loc{L}$ that contains $m$ branches which have loop relations $\psi_i$ and loop accelerations $\psi_i^*$ for $i \in 1 \ldots m$.\ts{use a different index, $i$ is the loophead index} A branching meta trace $\bar{\tau}$ is constructed from $\tau$ by replacing $\tau_L$ with the sequence $\tau_m: \psi_1^*, \varepsilon, \psi_2^*, \varepsilon, \ldots, \psi_n^* $. Where each $\psi_i$ leads to the new loop exit $\loc{L}'$ and each $\varepsilon$ from $\loc{L}'$ to $\loc{L}$.
\end{mydef}
A meta trace for branching loops represents the overall effect of the loop on the program state, however, it does not contain every trace through the loop. Traces where, for example, two branches alternate are not contained, as in the meta trace each branch is taken sequentially a finite amount of times. A meta trace for branching loops therefore represents an underapproximation of possible loop traces. \\ \par

For the trace $\tau_2$ we get the following branching meta trace:
\begin{figure}[H]
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=2.5cm, scale=1,
		transform shape, align=center,
		smallnode/.style={inner sep=1.4}
		initial text =]
		
		\node[state](1){$\loc{1}$};
		
		\node[state] (2) [right of=1] {$\loc{2}$};
		
		\node[state] (3) [right of=2, xshift=-0.55cm] {$\loc{2}'$};
		
		\node[state] (4) [right of=3, xshift=-0.55cm] {$\loc{2}$};
		
		\node[state] (5) [right of=4, xshift=-0.55cm] {$\loc{2}'$};
		
		\node[state] (6) [right of=5, xshift=0.4cm] {$\loc{7}$};
		
		\node[state] (7) [right of=6, xshift=0.4cm] {$\loc{9}$};
		
		\path (1) edge node {\texttt{x := 0}} (2);
		\path (2) edge node {$\psi^*_{L_{1}}$} (3);
		\path (3) edge node {$\varepsilon$} (4);
		\path (4) edge node {$\psi^*_{L_{2}}$} (5);
		\path (5) edge node {\texttt{!x <= 10}} (6);
		\path (6) edge node {\texttt{x != 11}} (7);
		;
	\end{tikzpicture}
	\captionof{figure}{Branching meta trace $\bar{\tau_2}$ generated from $\tau_2$.}
\end{figure}

\begin{figure}[H]
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=2.5cm, scale=1,
		transform shape, align=center,
		smallnode/.style={inner sep=1.4}
		initial text =]
		
		\node[state](1){$\loc{1}$};
		
		\node[state] (2) [right of=1] {$\loc{2}$};
		
		\node[state] (3) [right of=2, xshift=-0.55cm] {$\loc{2}'$};
		
		\node[state] (4) [right of=3, xshift=-0.55cm] {$\loc{2}$};
		
		\node[state] (5) [right of=4, xshift=-0.55cm] {$\loc{2}'$};
		
		\node[state] (6) [right of=5, xshift=0.4cm] {$\loc{7}$};
		
		\node[state] (7) [right of=6, xshift=0.4cm] {$\loc{9}$};
		
		\path (1) edge node {\texttt{x := 0}} (2);
		\path (2) edge node {$\psi^*_{L_{1}}$} (3);
		\path (3) edge node {$\varepsilon$} (4);
		\path (4) edge node {$\psi^*_{L_{2}}$} (5);
		\path (5) edge node {\texttt{!x <= 10}} (6);
		\path (6) edge node {\texttt{x != 11}} (7);
		;
	\end{tikzpicture}
	\captionof{figure}{Branching meta trace $\bar{\tau_2}$ generated from $\tau_2$.}
\end{figure}

Out of which an SMT-solver generates the following infeasibility proof:
\begin{figure}[H]
	\begin{tikzpicture}[%
		->,
		>=stealth', shorten >=1pt, auto,
		node distance=2.5cm, scale=1,
		transform shape, align=center,
		smallnode/.style={inner sep=1.4}
		initial text =]
		
		\node[state, label=above:{$\top$}](1){$\loc{1}$};
		
		\node[state, label=above:{$x = 0$}] (2) [right of=1] {$\loc{2}$};
		
		\node[state, xshift=-0.55cm, label={above:$\begin{aligned}
				& (5 \cdot x \leq 56 \\ &\lor x \leq 4) \\ &\land x \leq 9
			\end{aligned}$}] (3) [right of=2] {$\loc{2}'$};
		
		\node[state, xshift=-0.55cm, label={above:$\begin{aligned}
				& (5 \cdot x \leq 56 \\ &\lor x \leq 4) \\ &\land x \leq 9
			\end{aligned}$}] (4) [right of=3] {$\loc{2}$};
		
		\node[state,xshift=-0.55cm,  label=above:{$ x \leq 11$}] (5) [right of=4] {$\loc{2}'$};
		
		\node[state, xshift=0.4cm, label=above:{$x = 11$}] (6) [right of=5] {$\loc{7}$};
		
		\node[state, xshift=0.4cm, label=above:{$\bot$}] (7) [right of=6] {$\loc{9}$};
		
		\path (1) edge node {\texttt{x := 0}} (2); \\
		\path (2) edge node {$\psi_{L_{1}}^*$} (3); \\
		\path (3) edge node {$\varepsilon$} (4);\\
		\path (4) edge node {$\psi_{L_{2}}^*$} (5); \\
		\path (5) edge node {\texttt{!x <= 10}} (6); \\
		\path (6) edge node {\texttt{x != 11}} (7); \\
		;
	\end{tikzpicture}
	\captionof{figure}{Meta trace $\bar{\tau_2}$ and its infeasibility proof.}
\end{figure}
Interpolant sequence $I_{\bar{\tau}_2}: \{ \top,\ x = 0,\ 5 \cdot x \leq 56 \lor x \leq 4,\ 5 \cdot x \leq 56 \lor x \leq 4,\ x \leq 11,\ x = 11,\ \bot\}$ can be used to generate an inductive infeasibility proof for $\tau_2$ by using the post operator as explained before with one modification. \\ \par
Given an error trace $\tau: s_0, s_1, \ldots, s_n$ containing a loop $\tau_L: s_i, s_{i+1}, \ldots, s_j$ with loop head $\loc{L}$ that contains $m$ branches which have loop relations $\psi_i$ and loop accelerations $\psi_{i}^*$ for $i \in 1 \ldots m$ with branching meta trace $\bar{\tau}: s_0, s_1, \ldots, \psi_{1}^*, \varepsilon, \ldots, \varepsilon, \psi_{m}^*$ that has infeasibility proof in form of a sequence of interpolants $I_{\bar{\tau}}: \{\top, I_1, \ldots, I_{\psi_{1}}^*, \ldots, I_{\psi_{m}}^*, \ldots, I_{n - 1}, \bar \}$. For computing an inductive infeasibility proof for $\tau$ we use $I_{\bar{\tau}}$ and apply the $post$ operator in a similar fashion as explained before. But instead of applying $post$ to a singular loop entry interpolant and loop acceleration, we need to calculate the $post$ of all loop entry interpolants and loop accelerations. The first interpolant for the loop $I_i$ is then the conjunction of all these: $I_i = \bigwedge_{k=1}^{m} post(I_{\psi_k}^*, \psi_k^*)$. From this first interpolant we can then apply post until the end of the branching loop is reached.
\ts{Explain why this works.}
