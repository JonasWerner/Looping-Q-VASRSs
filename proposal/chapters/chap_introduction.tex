
Analyzing program loops is an important part of multiple software engineering tasks, such as bug detection, test case generation, and optimization. Loop analysis is, however, one of the most challenging aspects of program analysis, especially with complex loops that feature multiple paths and nested loops. Loop analysis has been called the "Archilles heel" of program verification\cite{0.1007/s10703-012-0176-y}. \par
There are three prominent techniques of loop analysis: loop unwinding, loop invariant calculation, and loop summarization\cite{0.1007/s10703-012-0176-y, 8241837,10.1007/978-3-030-25543-5_7}. Loop unwinding deals with a loop by unrolling each loop iteration until a certain number. This technique is quite simple but cannot reason about the program behavior beyond the unwinding bound. \\
Loop invariants are properties that hold before and after each loop iteration, modeling its behaviour. The usefulness of loop invariants is however tied to how strong they are, and finding sufficiently strong invariants "is an art"\cite{0.1007/s10703-012-0176-y}. A software-model checker, for example, may not terminate if given loop invariants are insufficiently general. \par
Loop summarization on the other hand provides a more accurate and complete view of the loop. A loop summary models the relationship between inputs and outputs as a set of constraints that can be used to replace the loop in a program. Loop summaries are not guaranteed to be precise, meaning they can over- or underapproximate the loop's behavior. Counterexamples found using underapproximative loop summaries are guaranteed to be feasible counterexamples, the summaries can, however, miss feasible counterexample as they model only a subset of the actual loop behavior \cite{10.1007/s10703-015-0228-1}. Overapproxiamtive loop summaries on the other hand form a superset over the actual loop behavior, resulting in possible spurious counterexamples. The quality of overapproximative loop summaries depends on how much the summary overapproximates the actual loop behavior.\\ \par
Silverman and Kincaid\cite{10.1007/978-3-030-25543-5_7} proposed an overapproximative loop summarization that guarantees a certain degree of approximation precision.\par 
The proposed technique makes use of \textsl{rational vector addition systems} (\qvasr). A \qvasr of dimension $d$ is a finite set $V \subseteq \{0, 1\}^d \times \mathbb{Q}^d$ of transformers. Each transformer $(\vec{r}, \vec{a}) \in V$ consists of binary \textsl{reset} vector $\vec{r}$ and rational \textsl{addition} vector $\vec{a}$. These transformer model transitions between two vectors $\vec{u}$ and $\vec{v}$ the following way: $\vec{v}\ =\ \vec{u}\ *\ \vec{r}\ +\ \vec{a}$, with * being the Hadamard product. It is possible to construct a \qvasr for transition formulas. For example, given transition formula $G: x' = x + 1 \land y' = 2$, we see that $x$ is not reset but incremented by 1 and $y$ is reset and incremented by 2. Resulting in reset vector $\vec{r}_F: \begin{pmatrix} 1 \\ 0\end{pmatrix}$ and addition vector $\vec{a}_F: \begin{pmatrix} 1 \\ 2\end{pmatrix}$. \par
\qvasr only model transitions with constant resets and increments. Consider transition formula $H: x' = x + y\ \land\ y' = y + 1 \land z' = x$, we see that $x$ is not reset but increased by variable amount $y$, whereas $z$ is reset and incremented by $x$. To solve this we need to simulate variable relations to the \qvasr. Given a \qvasr $V$ of dimension $d$ and a transition formula $F$ with $n$ variables, a \textsl{linear simulation} $S: \mathbb{Q}^{d \times n} $ is a rational matrix consisting of dimensions $d$ and $n$ such that transitions between two vectors $\vec{u}$ and $\vec{v}$ in $F$ can be represented as $S\vec{v} = S\vec{u} * \vec{r} + \vec{a}$ for some $(\vec{r}, \vec{a}) \in V$. The tuple $(S, V)$ is called a \qvasr-abstraction and is not unique. To get the most precise overapproximation of the reflexive transitive closure of a transition formula we need the \textsl{best} \qvasr-abstraction $(\tilde{S}, \tilde{V})$ that simulates the most transitions of the formula, for that we impose a partial order $\preceq$ on \qvasr-abstractions where $(S, V) \preceq (\tilde{S}, \tilde{V})$ for all other \qvasr-abstractions. $(\tilde{S}, \tilde{V})$ is the least upper bound with regard to $\preceq$ and is computed by iteratively joining abstractions. The best abstraction is then used to compute the reflexive, transitive closure of a transition formula. \\ Illustrating the notion of \qvasr and \qvasr-abstractions further, we introduce Figure \ref{code} which shows an example program consisting of a loop and Figure \ref{vasr} depicting the loop's best \qvasr-abstraction $(S,V)$. $V$ consists of two reset and addition vector pairs representing the two branches of the \texttt{if else} branching in the loop. Having multiple pairs of reset and addition vectors can lead to a loss in precision. In the example, we see that the conditions of the \texttt{if} and \texttt{else} branch, \texttt{x <= 10} and \texttt{x > 10}, are not modeled in $V$, leading to the inclusion of transitions that would violate these conditions in the actual loop. \\
\begin{minipage}[t]{0.3\linewidth} \centering
	\begin{figure}[H]
		\input{fig/lst_ex_p0.tex}
		\caption{Program $P$ \\ with \texttt{while} loop.}
		\label{code}
	\end{figure}
\end{minipage}
\begin{minipage}[t]{0.35\linewidth} \centering
	\begin{figure}[H]
			\input{fig/matrix_ex_p0.tex}
			\caption{\\ Best \qvasr-abstraction \\ of $P$'s loop.}
			\label{vasr}
	\end{figure}
\end{minipage}
\begin{minipage}[t]{0.3\linewidth} \centering
	\begin{figure}[H]
		\input{fig/qvasrs_ex_p0.tex}
		\caption{\\ \qvasrs of $P$'s loop.}
		\label{vasrs}
	\end{figure}
\end{minipage}
\vspace*{1cm}

To improve precision we introduce $\qvasr$ with states (\qvasrs). Given a \qvasr $V$, a \qvasrs of dimension $d$ is a pair $\mathcal{V} = (P, E)$, with $P$ being a finite set of control states given as predicates and $E \subseteq P \times (\vec{r}, \vec{a}) \times P$ with $(\vec{r}, \vec{a}) \in V$ being a finite set of edges. For all $p \neq q \in P$ we have $p\ \land\ q$ unsatisfiable. Now, a \qvasrs can transition between two vectors $\vec{u}$ and $\vec{v}$ if there is an edge $(p,\ (\vec{r},\ \vec{a}),\ q) \in E$, with $\vec{v} = \vec{r} * \vec{u} + \vec{a}$. \par
Figure \ref{vasrs} details the \qvasrs of program $P's$ loop, in which the \texttt{if else} conditions hold. \par
To compute the reflexive transitive closure of a \qvasrs one has to calculate its reachability relation. Haase and Halfon \cite{10.1007/978-3-319-11439-2_9} proposed a polytime procedure that unwinds vector addition systems into multiple formulas that as conjunction form the reflexive transitive closure. This procedure can be adapted to work with \qvasrs. \\ \par

\textsc{Utimate}\cite{Zitat02} is a software analysis framework consisting of multiple plugins and libraries for various software verification tasks. \textsc{Ultimate} already features multiple loop summarization techniques, they, however, have problems with nested loops, loop branching, and approximation precision. Problems that can potentially be remedied by \qvasrs. We plan on implementing a new loop summarization library based on \qvasrs, integrate it into the \texttt{accelerated interpolation} scheme, which computes state assertions for programs utilizing loop summaries, and compare the performance of \qvasrs to other loop summarization techniques.
The remainder of this proposal is structured as follows, in section 2 we formulate our problem statement, followed by an outline of the approach of the project in section 3, and last but not least a timetable showing the chronological order of the project in section 4.
