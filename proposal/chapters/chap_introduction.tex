
Analyzing program loops is an important part of multiple software engineering tasks, such as bug detection, test case generation, and optimization. Loop analysis is, however, one of the most challenging aspects of program analysis, especially with complex loops that feature multiple paths and nested loops. Loop analysis has been called the "Archilles heel" of program verification\cite{0.1007/s10703-012-0176-y}. \par
There are three prominent techniques of loop analysis: loop unwinding, loop invariant calculation, and loop summarization\cite{0.1007/s10703-012-0176-y, 8241837,10.1007/978-3-030-25543-5_7}. Loop unwinding deals with a loop by unrolling each loop iteration until a certain number. This technique is quite simple but cannot reason about the program behavior beyond the unwinding bound. \\
Loop invariants are properties that hold before and after each loop iteration, modeling its behaviour. The usefulness of loop invariants is however tied to how strong they are, and finding sufficiently strong invariants "is an art"\cite{0.1007/s10703-012-0176-y}. A software-model checker, for example, may not terminate if given loop invariants are insufficiently general. \par
Loop summarization on the other hand provides a more accurate and complete view of the loop. A loop summary models the relationship between inputs and outputs as a set of constraints that can be used to replace the loop in a program. Loop summaries are not guaranteed to be precise, meaning they can over- or underapproximate the loop's behavior. Counterexamples found using underapproximative loop summaries are guaranteed to be feasible counterexamples, the summaries can, however, miss feasible counterexample as they model only a subset of the actual loop behavior \cite{10.1007/s10703-015-0228-1}. Overapproxiamtive loop summaries on the other hand form a superset over the actual loop behavior, resulting in possible spurious counterexamples. The quality of overapproximative loop summaries depends on how much the summary overapproximates the actual loop behavior.\par
\jw{Todo: \qvasr and \qvasrs introduction}
Silverman and Kincaid\cite{10.1007/978-3-030-25543-5_7} proposed an overapproximative loop summarization that guarantees a certain degree of approximation precision.\par 
The proposed technique makes use of \textsl{rational vector addition systems} (\qvasr). A \qvasr of dimension $d$ is a finite set $V \subseteq \{0, 1\}^d \times \mathbb{Q}^d$ of transformers. Each transformer consists of binary \textsl{reset} vector $\vec{r}$ and rational \textsl{addition} vector $\vec{a}$. These transformer model transitions between two vectors $\vec{u}$ and $\vec{v}$ the following way: $\vec{v}\ =\ \vec{u}\ *\ \vec{r}\ +\ \vec{a}$, with * being the Hadamard product.
\qvasr can be used to model transition formulas:\\ Given transition formula $F: x' = x + 1 \land y' = 2$, we see that $x$ is not reset but incremented by 1 and $y$ is reset to 0 and incremented by 2. Resulting in reset vector $\vec{r}_F: \begin{pmatrix} 1 \\ 0\end{pmatrix}$ and addition vector $\vec{a}_F: \begin{pmatrix} 1 \\ 2\end{pmatrix}$. \par
\qvasr can however not model every transition formula, ...

\jw{Todo: We need the simulation matrix S for relations between variables -> \qvasr abstraction, we need the partial order for best abstraction -> ties in with the precision claim, need \qvasrs -> states/predicates improve accuracy by constraining nondeterminism}

\begin{minipage}[t]{0.3\linewidth} \centering
	\begin{figure}[H]
		\input{fig/lst_ex_p0.tex}
		\caption{Program $P$ \\ with \texttt{while} loop.}
	\end{figure}
\end{minipage}
\begin{minipage}[t]{0.35\linewidth} \centering
	\begin{figure}[H]
			\input{fig/matrix_ex_p0.tex}
			\caption{\\ \qvasr-abstraction \\ of $P$'s loop.}
	\end{figure}
\end{minipage}
\begin{minipage}[t]{0.3\linewidth} \centering
	\begin{figure}[H]
		\input{fig/qvasrs_ex_p0.tex}
		\caption{\\ \qvasrs-abstraction of $P$'s loop.}
	\end{figure}
\end{minipage}